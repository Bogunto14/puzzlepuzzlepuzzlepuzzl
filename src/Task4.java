
import javafx.application.Application;
import javafx.scene.Group;
import javafx.scene.Scene;
import javafx.scene.control.Button;
import javafx.scene.control.TextArea;
import javafx.scene.image.Image;
import javafx.scene.image.ImageView;
import javafx.scene.text.Text;
import javafx.stage.Stage;

public class Task4 extends Application{

    public static void main (String[] args){
        launch(args);
    }

    @Override public void start(Stage primaryStage) throws Exception{
        Group root = new Group();
        primaryStage.setScene(new Scene(root));

        ImageView backgroundBlack = new ImageView(new Image(getClass().getResourceAsStream("images/6.jpg")));

        TextArea textArea = new TextArea();
        textArea.setText("Списки\n" +
                        " \n" +
                        "Список — это один из очень распространённых составных типов со следующими свойствами:\n" +
                        "\n" +
                        " 1)список может включать в себя произвольное количество элементов (от нуля до бесконечности);\n" +
                        "\n" +
                        " 2)количество элементов в списке называется его размером;\n" +
                        "\n" +
                        " 3)все элементы списка имеют один и тот же тип (в свою очередь, этот тип может быть простым — список вещественных чисел, \n" +
                        " или составным — список строк, или список списков целых чисел, или любые другие варианты);\n" +
                        "\n" +
                        " 4)в остальном элементы списка независимы друг от друга.\n" +
                        " \n" +
                        "List в Котлине — это и есть список. В угловых скобках <> указывается так называемый типовой аргумент — тип элементов списка, \n" +
                        "то есть List<Double> вместе — это список вещественных чисел. Для создания списков, удобно использовать функцию listOf().\n" +
                        "Аргументы этой функции — это элементы создаваемого списка, их может быть произвольное количество (в том числе 0). \n" +
                        "В ряде случаев, когда биквадратное уравнение не имеет корней, функция biRoots возвращает пустой список результатов.\n" +
                        "\n" +
                        "Обратите внимание, что мы используем запись listOf<Double>() для создания пустого списка. Дело в том,\n" +
                        " что для вызовов вроде listOf(-2.0, 2.0) тип элементов создаваемого списка понятен из аргументов функции — это List<Double>. " +
                        "А вот вызов listOf() без аргументов не даёт никакой информации о типе элементов списка, в то же время, например,\n" +
                        " пустой список строк и пустой список целых чисел — с точки зрения Котлина не одно и то же." +
                        "\n" +
                        "Мы уже встречались с функциями с получателем .toInt() и .toDouble(). Функция .sorted() также требует наличия получателя:\n" +
                        " вызов list.sorted() создаёт список того же размера, что и исходный, но его элементы будут упорядочены по возрастанию.\n" +
                        "Распространённые операции над списками\n" +
                        "Перечислим некоторые операции над списками, имеющиеся в библиотеке языка Котлин:\n" +
                        "\n" +
                        " 1)listOf(…\u200B) — создание нового списка.\n" +
                        "\n" +
                        " 2)list1 + list2 — сложение двух списков, сумма списков содержит все элементы их обоих.\n" +
                        "\n" +
                        " 3)list + element — сложение списка и элемента, сумма содержит все элементы list и дополнительно element\n" +
                        "\n" +
                        " 4)list.size — получение размера списка (Int).\n" +
                        "\n" +
                        " 5)list.isEmpty(), list.isNotEmpty() — получение признаков пустоты и непустоты списка (Boolean).\n" +
                        "\n" +
                        " 6)list[i] — индексация, то есть получение элемента списка с целочисленным индексом (номером) i. По правилам Котлина, \n" +
                        " в списке из n элементов они имеют индексы, начинающиеся с нуля: 0, 1, 2, …\u200B, последний элемент списка имеет индекс n - 1.\n" +
                        " То есть, при использовании записи list[i] должно быть справедливо i >= 0 && i < list.size. В противном случае выполнение программы \n" +
                        " будет прервано с ошибкой (использование индекса за пределами границ списка).\n" +
                        "\n" +
                        " 7)list.sublist(from, to) — создание списка меньшего размера (подсписка), в который войдут элементы списка list с индексами from,\n" +
                        " from + 1, …\u200B, to - 2, to - 1. Элемент с индексом to не включается.\n" +
                        "\n" +
                        " 8)element in list — проверка принадлежности элемента element списку list.\n" +
                        "\n" +
                        " 9)for (element in list) { …\u200B } — цикл for, перебирающий все элементы списка list.\n" +
                "\n" +
                        " 10)list.first() — получение первого элемента списка (если список пуст, выполнение программы будет прервано с ошибкой).\n" +
                        "\n" +
                        " 11)list.last() — получение последнего элемента списка (аналогично).\n" +
                        "\n" +
                        " 12)list.indexOf(element) — поиск индекса элемента element в списке list. Результат этой функции равен -1, если элемент в списке отсутствует. \n" +
                        " В противном случае, при обращении к списку list по вычисленному индексу мы получим element.\n" +
                        "\n" +
                        " 13)list.min(), list.max() — поиск минимального и максимального элемента в списке.\n" +
                        "\n" +
                        " 14)list.sum() — сумма элементов в списке.\n" +
                        "\n" +
                        " 15)list.sorted(), list.sortedDescending() — построение отсортированного списка (по возрастанию или по убыванию) из имеющегося.\n" +
                        "\n" +
                        " 16)list1 == list2 —  сравнение двух списков на равенство. Списки равны, если равны их размеры и соответствующие элементы.\n" +
                        " \n" +
                        "Мутирующие списоки\n" +
                        " \n" +
                        "Мутирующий список является разновидностью обычного, его тип определяется как MutableList<ElementType>. В дополнение к тем возможностям, \n" +
                        "которые есть у всех списков в Котлине, мутирующий список может изменяться по ходу выполнения программы или функции. Это означает, что мутирующий список позволяет:\n" +
                        "\n" +
                        " 1)Изменять своё содержимое операторами list[i] = element.\n" +
                        "\n" +
                        " 2)Добавлять элементы в конец списка, с увеличением размера на 1: list.add(element).\n" +
                        "\n" +
                        " 3)Удалять элементы из списка, с уменьшением размера на 1 (если элемент был в списке): list.remove(element).\n" +
                        "\n" +
                        " 4)Удалять элементы из списка по индексу, с уменьшением размера на 1: list.removeAt(index).\n" +
                        "\n" +
                        " 5)Вставлять элементы в середину списка: list.add(index, element) — вставляет элемент element по индексу index, сдвигая все последующие элементы на 1, \n" +
                        " например listOf(1, 2, 3).add(1, 7) даст результат [1, 7, 2, 3].\n" +
                        "\n" +
                        " Для создания мутирующего списка можно использовать функцию mutableListOf(…\u200B), аналогичную listOf(…\u200B).\n" +
                        " \n" +
                        "Функции высшего порядка\n" +
                        " \n" +
                        "Функция высшего порядка функция - это функция, которая принимает в качестве параметра другую функцию.\n" +
                        " \n" +
                        "Функция filter передаёт функции-аргументу каждый элемент списка. Если функция-аргумент вернула true, элемент помещается в список-результат, если false — он фильтруется.\n" +
                        " \n" +
                        "Более короткая запись list.filter({ it < 0 }) использует так называемую лямбду { it < 0 } в качестве аргумента функции filter. \n" +
                        "Этот краткий синтаксис не включает в себя не только имени функции, но и ключевого слова fun, а также явного указания имён и типов параметров. \n" +
                        "При этом предполагается, что:\n" +
                        "\n" +
                        "параметр называется it; если параметру хочется дать другое имя, лямбда записывается как, например, { element -> element < 0 }\n" +
                        "\n" +
                        "тип параметра — ровно тот, который требуется функции высшего порядка, для filter это тип элементов списка\n" +
                        "\n" +
                        "тип результата — опять-таки ровно тот, что требуется\n" +
                        "\n" +
                        "в фигурные скобки помещается блок, определяющий результат функции; в идеале он состоит из одного оператора, в данном случае это it < 0\n" +
                        " \n" +
                        "Наконец, функция высшего порядка fold предназначена для \"сворачивания\" списка в один элемент или значение. Например:\n" +
                        "\n" +
                        "fun multiplyAll(list: List<Int>) = list.fold(1.0) {\n" +
                        "previousResult, element -> previousResult * element\n" +
                        "}\n" +
                        "Функция fold работает следующим образом. Изначально она берёт свой первый аргумент (в данном примере 1.0) и сохраняет его как текущий результат. \n" +
                        "Далее перебираются все элементы списка получателя и для каждого из них применяется указанная лямбда,\n" +
                        "которая из текущего результата previousResult с предыдущего шага и очередного элемента element делает текущий результат этого шага \n" +
                        "(в данном примере предыдущий результат домножается на очередной элемент). \n" +
                        "По окончании элементов списка последний текущий результат становится окончательным.\n" +
                " В данном примере результатом будет произведение всех элементов списка (или 1.0, если список пуст).\n" +
                        "\n" +
                        "Строки\n" +
                        " \n" +
                        "Строки String во многих отношениях подобны спискам, хотя формально и не являются ими. Список состоит из однотипных элементов, \n" +
                        "к которым можно обращаться по индексу и перебирать с помощью цикла for. Строки же точно так же состоят из символов Char,\n" +
                        "к которым также можно обращаться по индексу и которые также можно перебирать с помощью цикла for.\n" +
                        "\n" +
                        "Напомним, что строковый литерал (явно указанная строка) в Котлине записывается в двойных кавычках. Переменную name произвольного типа можно\n" +
                        " преобразовать в строку, используя запись \"$name\" — строковый шаблон, или чуть более сложную запись name.toString() с тем же самым результатом.\n" +
                        "Как мы видим, $ внутри строкового литерала имеет специальный смысл — вместо $name в строку будет подставлено содержимое переменной name. Как быть,\n" +
                        " если мы хотим просто включить в строку символ доллара? В этом случае следует применить так называемое экранирование, \n" +
                        " добавив перед символом доллара символ \\. Например: \"The price is 9.99 \\$\".\n" +
                        " \n" +
                        "Очень часто используемой в Котлине является сложная функция преобразования списка в строку joinToString().\n" +
                        "Получателем данной функции может быть список с произвольным типом элементов: List<T>. Такая запись описывает так называемую настраиваемую функцию, о них мы \n" +
                        "будем говорить подробнее позже.");
        textArea.setTranslateX(50);
        textArea.setTranslateY(50);
        textArea.setPrefSize(900, 600);

        Button buttonStart = new Button("Запомнил!");
        buttonStart.setTranslateX(450);
        buttonStart.setTranslateY(660);
        buttonStart.setOnAction(e -> startPuzzle(primaryStage));

        root.getChildren().addAll(backgroundBlack,textArea,buttonStart);

    }

    public static void startPuzzle(Stage primaryStage) {
        Puzzle4 pp = new Puzzle4();
        try {
            pp.start(primaryStage);
        } catch (Exception e) {
            e.printStackTrace();
        }
    }
}